---
title: "Hello, Quarto"
format: html
echo: false
message: false
warning: false
---

```{python}
from lifelines import AalenJohansenFitter
import numpy as np
from itertools import product
import itertools
from rtichoke.helpers.sandbox_observable_helpers import *
from lifelines import CoxPHFitter
from lifelines import WeibullAFTFitter
import polars as pl
print("Polars version:", pl.__version__)

import pandas as pd
import pickle  

with open(r'C:\Users\I\Documents\GitHub\rtichoke_python\probs_dict.pkl', 'rb') as file:
    probs_dict = pickle.load(file)

with open(r'C:\Users\I\Documents\GitHub\rtichoke_python\reals_dict.pkl', 'rb') as file:
    reals_dict = pickle.load(file)

with open(r'C:\Users\I\Documents\GitHub\rtichoke_python\times_dict.pkl', 'rb') as file:
    times_dict = pickle.load(file)


```


## polars

```{python}



fixed_time_horizons = [1, 3, 5]
stratified_by = ["probability_threshold", "ppcr"]
by=0.1

aj_data_combinations = create_aj_data_combinations_polars(list(probs_dict.keys()), fixed_time_horizons, stratified_by, by)



print(aj_data_combinations['strata'])
```

# try polars

## create list data to adjust polars

```{python}

from rtichoke.helpers.sandbox_observable_helpers import *

list_data_to_adjust_polars = create_list_data_to_adjust_polars(
  probs_dict, reals_dict, times_dict, stratified_by=stratified_by, by=by
)



```


## create adjusted data list polars

### New extract aj estimate by assumptions polars

#### One polars dataframe

```{python}

example_polars_df = list_data_to_adjust_polars.get('full').select(pl.col("strata"), pl.col("reals"), pl.col("times"))

fixed_time_horizons = [1, 3, 5]

def extract_aj_estimate_for_strata(
  data_to_adjust, 
  fixed_time_horizons_for_aj):
  
  ajf_primary = AalenJohansenFitter()
  ajf_competing = AalenJohansenFitter()

  ajf_primary.fit(
    data_to_adjust['times'].to_pandas(),
    data_to_adjust['reals'].to_pandas(),
    event_of_interest=1
  )

  ajf_competing.fit(
    data_to_adjust['times'].to_pandas(),
    data_to_adjust['reals'].to_pandas(),
    event_of_interest=2
  )

  n = data_to_adjust.height

  real_positives_est = ajf_primary.predict(fixed_time_horizons_for_aj)
  real_competing_est = ajf_competing.predict(fixed_time_horizons_for_aj)
  real_negatives_est = 1 - real_positives_est - real_competing_est

  return pl.DataFrame({
    "strata": data_to_adjust['strata'][0],
    "fixed_time_horizon": fixed_time_horizons_for_aj,
    "real_negatives_est": real_negatives_est*n,
    "real_positives_est": real_positives_est*n,
    "real_competing_est": real_competing_est*n
  })

```


## AJ estimates per assumptions

```{python}

# 1 adjusted - adjusted_as_negative

aj_estimates_per_strata_adj_adjneg = example_polars_df.group_by("strata").map_groups(
  lambda group: extract_aj_estimate_for_strata(group, fixed_time_horizons)).join(pl.DataFrame({"real_censored_est": 0.0, "censoring_assumption": "adjusted", "competing_assumption": "adjusted_as_negative"}), how = 'cross')


# 2 excluded - adjusted as negative

exploded_data = example_polars_df.with_columns(fixed_time_horizon = pl.lit([1,3,5])).explode("fixed_time_horizon")

aj_estimates_per_strata_censored = exploded_data.filter((pl.col("times") < pl.col("fixed_time_horizon")) & pl.col("reals")==0).group_by(["strata", "fixed_time_horizon"]).count().rename({"count": "real_censored_est"}).with_columns(
    pl.col("real_censored_est").cast(pl.Float64)
)

non_censored_data = exploded_data.filter((pl.col("times") >= pl.col("fixed_time_horizon")) | pl.col("reals")>0)


aj_estimates_per_strata_noncensored = pl.concat(
    [
        non_censored_data
        .filter(pl.col("fixed_time_horizon") == fixed_time_horizon)
        .group_by("strata")
        .map_groups(lambda group: extract_aj_estimate_for_strata(group, fixed_time_horizon))
        for fixed_time_horizon in fixed_time_horizons
    ],
    how="vertical"
)

aj_estimates_per_strata_excl_adjneg = aj_estimates_per_strata_noncensored.join(
  aj_estimates_per_strata_censored, 
  on = ['strata', 'fixed_time_horizon']
).join(pl.DataFrame({"censoring_assumption": "excluded", "competing_assumption": "adjusted_as_negative"}), how = 'cross')


# 3 adjusted - adjusted as censored


aj_estimates_per_strata_adj_adjcens = example_polars_df.with_columns([
        pl.when(
            (pl.col("reals") ==2)
        ).then(pl.lit(0))
            .otherwise(pl.col("reals"))
         .alias("reals")
    ]).group_by("strata").map_groups(
  lambda group: extract_aj_estimate_for_strata(group, fixed_time_horizons)).join(pl.DataFrame({"real_censored_est": 0.0, "censoring_assumption": "adjusted", "competing_assumption": "adjusted_as_censored"}), how = 'cross')

# 4 excluded - adjusted as censored

exploded_data = example_polars_df.with_columns(fixed_time_horizon = pl.lit([1,3,5])).explode("fixed_time_horizon")

aj_estimates_per_strata_censored = exploded_data.filter((pl.col("times") < pl.col("fixed_time_horizon")) & pl.col("reals")==0).group_by(["strata", "fixed_time_horizon"]).count().rename({"count": "real_censored_est"}).with_columns(
    pl.col("real_censored_est").cast(pl.Float64)
)

non_censored_data = exploded_data.filter((pl.col("times") >= pl.col("fixed_time_horizon")) | pl.col("reals")>0).with_columns([
        pl.when(
            (pl.col("reals") ==2)
        ).then(pl.lit(0))
            .otherwise(pl.col("reals"))
         .alias("reals")
    ])


aj_estimates_per_strata_noncensored = pl.concat(
    [
        non_censored_data
        .filter(pl.col("fixed_time_horizon") == fixed_time_horizon)
        .group_by("strata")
        .map_groups(lambda group: extract_aj_estimate_for_strata(group, fixed_time_horizon))
        for fixed_time_horizon in fixed_time_horizons
    ],
    how="vertical"
)

aj_estimates_per_strata_excl_adjcens = aj_estimates_per_strata_noncensored.join(
  aj_estimates_per_strata_censored, 
  on = ['strata', 'fixed_time_horizon']
).join(pl.DataFrame({"censoring_assumption": "excluded", "competing_assumption": "adjusted_as_negative"}), how = 'cross')



## 5 adjusted - excluded

exploded_data = example_polars_df.with_columns(fixed_time_horizon = pl.lit([1,3,5])).explode("fixed_time_horizon")

aj_estimates_per_strata_competing = exploded_data.filter((pl.col("reals")==2) & (pl.col("times") < pl.col("fixed_time_horizon"))).group_by(["strata", "fixed_time_horizon"]).count().rename({"count": "real_competing_est"}).with_columns(
    pl.col("real_competing_est").cast(pl.Float64)
)

non_competing_data = exploded_data.filter((pl.col("times") >= pl.col("fixed_time_horizon")) | pl.col("reals")!=2).with_columns([
        pl.when(
            (pl.col("reals") ==2)
        ).then(pl.lit(0))
            .otherwise(pl.col("reals"))
         .alias("reals")
    ])


aj_estimates_per_strata_noncompeting = pl.concat(
    [
        non_competing_data
        .filter(pl.col("fixed_time_horizon") == fixed_time_horizon)
        .group_by("strata")
        .map_groups(lambda group: extract_aj_estimate_for_strata(group, fixed_time_horizon))
        for fixed_time_horizon in fixed_time_horizons
    ],
    how="vertical"
).select(pl.exclude("real_competing_est"))

aj_estimates_per_strata_adj_excl = aj_estimates_per_strata_competing.join(
  aj_estimates_per_strata_noncompeting, 
  on = ['strata', 'fixed_time_horizon']
).join(pl.DataFrame({"real_censored_est": 0.0, "censoring_assumption": "adjusted", "competing_assumption": "excluded"}), how = 'cross').select(
  ['strata',
 'fixed_time_horizon',
 'real_negatives_est',
 'real_positives_est',
 'real_competing_est',
 'real_censored_est',
 'censoring_assumption',
 'competing_assumption']
)


## 6 excluded - excluded


exploded_data = example_polars_df.with_columns(fixed_time_horizon = pl.lit([1,3,5])).explode("fixed_time_horizon")

aj_estimates_per_strata_censored = exploded_data.filter((pl.col("times") < pl.col("fixed_time_horizon")) & pl.col("reals")==0).group_by(["strata", "fixed_time_horizon"]).count().rename({"count": "real_censored_est"}).with_columns(
    pl.col("real_censored_est").cast(pl.Float64)
)

aj_estimates_per_strata_competing = exploded_data.filter((pl.col("reals")==2) & (pl.col("times") < pl.col("fixed_time_horizon"))).group_by(["strata", "fixed_time_horizon"]).count().rename({"count": "real_competing_est"}).with_columns(
    pl.col("real_competing_est").cast(pl.Float64)
)


non_censored_non_competing_data = exploded_data.filter(((pl.col("times") >= pl.col("fixed_time_horizon")) | pl.col("reals")==1))


aj_estimates_per_strata_noncompeting_noncompeting = pl.concat(
    [
        non_censored_non_competing_data
        .filter(pl.col("fixed_time_horizon") == fixed_time_horizon)
        .group_by("strata")
        .map_groups(lambda group: extract_aj_estimate_for_strata(group, fixed_time_horizon))
        for fixed_time_horizon in fixed_time_horizons
    ],
    how="vertical"
)

aj_estimates_per_strata_excl_excl = aj_estimates_per_strata_competing.join(aj_estimates_per_strata_censored, on = ['strata', 'fixed_time_horizon']).join(
  aj_estimates_per_strata_noncompeting, 
  on = ['strata', 'fixed_time_horizon']
).join(pl.DataFrame({"censoring_assumption": "excluded", "competing_assumption": "excluded"}), how = 'cross').select(
  ['strata',
 'fixed_time_horizon',
 'real_negatives_est',
 'real_positives_est',
 'real_competing_est',
 'real_censored_est',
 'censoring_assumption',
 'competing_assumption']
)

## combine all

aj_estimates_data = pl.concat(
  [
    aj_estimates_per_strata_adj_adjneg,
    aj_estimates_per_strata_adj_adjcens,
    aj_estimates_per_strata_adj_excl,
    aj_estimates_per_strata_excl_adjneg,
    aj_estimates_per_strata_excl_adjcens,
    aj_estimates_per_strata_excl_excl
  ]
).unpivot( index = ["strata", "fixed_time_horizon", "censoring_assumption", "competing_assumption"] , variable_name = "reals_labels", value_name = "reals_estimate")


```

### Check strata values

```{python}

aj_data_combinations.select(pl.col('strata')).with_columns(
  pl.col("strata").cast(str)
).join(
  aj_estimates_data.select(pl.col('strata')).unique(),
  on = 'strata'
)
  
result = aj_data_combinations.select(pl.col('strata')).with_columns(
  pl.col("strata").cast(str)
).with_columns(
    pl.col("strata").is_in(aj_estimates_data["strata"]).alias("is_in_df2")
)

print(result)


result = aj_estimates_data.select(pl.col('strata')).with_columns(
  pl.col("strata")
).with_columns(
    pl.col("strata").is_in(aj_data_combinations["strata"].cast(str)).alias("is_in_df2")
)

print(result.filter(pl.col("is_in_df2") == False))


```

### Cast varibles with hacks

```{python}

reals_enum_dtype = aj_data_combinations.schema["reals_labels"]
censoring_assumptions_enum_dtype = aj_data_combinations.schema["censoring_assumption"]
competing_assumptions_enum_dtype = aj_data_combinations.schema["competing_assumption"]

strata_enum_dtype = aj_data_combinations.schema["strata"]


aj_estimates_data = aj_estimates_data.with_columns([
    pl.col("strata").cast(pl.Categorical)
]).with_columns(
    pl.col("reals_labels").str.replace(r"_est$", "").cast(reals_enum_dtype)
).with_columns(
  pl.col("censoring_assumption").cast(censoring_assumptions_enum_dtype)
).with_columns(
  pl.col("competing_assumption").cast(competing_assumptions_enum_dtype)
).with_columns(
  pl.col("strata").cast(str)#.cast(strata_enum_dtype)
)

```

```{python}


final_adjusted_data_polars = aj_data_combinations.with_columns([
    pl.col("strata").cast(str)
]).join(
  aj_estimates_data, 
  on = ['strata', 'fixed_time_horizon', 'censoring_assumption', 'competing_assumption', 'reals_labels'],
  how = 'left'
)


```


```{python}

import pandas as pd


reference_groups = list(probs_dict.keys())


ojs_define(reference_groups_data = reference_groups)

ojs_define(data = final_adjusted_data_polars.to_pandas())

```

## Observable stuff

```{ojs}
//| panel: input

viewof time_horizon = Inputs.range(
  [1, 5], 
  {value: 3, step: 2, label: "Time Horizon:"}
)

viewof reference_group = Inputs.radio(
  reference_groups_data, {label: "Reference Group"}, {value: 'thin'}
)

viewof stratified_by = Inputs.radio(
  ["probability_threshold", "ppcr"], {value: "probability_threshold", label: "Stratified By"}
)

viewof censored_assumption = Inputs.radio(
  ["excluded", "adjusted"], {value: "excluded", label: "Censored Assumption"}
)

viewof competing_assumption = Inputs.radio(
  ["excluded", "adjusted_as_negative", "adjusted_as_censored"], {value: "excluded", label: "Competing Assumption"}
)

```

```{ojs}

//cumulative_aj_data_filtered = transpose(cumulative_aj_data).filter(function(subset) {
//
//  return time_horizon == subset.fixed_time_horizon &&
//         censored_assumption == subset.censored_assumption &&
//         competing_assumption == subset.competing_assumption &&
//         stratified_by == subset.stratified_by && 
//         reference_group === subset.reference_group;
//})

filtered = transpose(data).filter(function(subset) {

  return time_horizon == subset.fixed_time_horizon &&
         censored_assumption == subset.censoring_assumption &&
         competing_assumption == subset.competing_assumption &&
         stratified_by === subset.stratified_by && 
         reference_group === subset.reference_group;
})

filtered


```

```{ojs}

  
Plot.plot({
  marks: [
    Plot.barY(filtered, { 
      x: "strata", 
      y: "reals_estimate", 
      fill: "reals_labels", 
      tip: true 
    })
  ],
  color: {
    domain: ["real_positives", "real_competing", "real_negatives", "real_censored"], 
    range: ["#009e73", "#9DB4C0", "#FAC8CD", "#E3F09B"],
    legend: true
  }
})

```

```{python}

# combined_adjusted_data.dropna(subset=['reals_estimate'])
# # 

# Perform left join between aj_data_combinations and final_adjusted_data on 'strata' and 'reals_estimate'
# only when stratified_by == 'probability_threshold' for aj_data_combinations

# aj_data_combinations_prob_threshold = aj_data_combinations[aj_data_combinations['stratified_by'] == 'probability_threshold']

# # Convert 'strata' columns to strings
# aj_data_combinations_prob_threshold['strata'] = aj_data_combinations_prob_threshold['strata'].astype(str)
# final_adjusted_data['strata'] = final_adjusted_data['strata'].astype(str)

# combined_adjusted_data = aj_data_combinations_prob_threshold.merge(
#     final_adjusted_data[['strata', 'reals', 'reals_estimate']],
#     on=['strata', 'reals'],
#     how='left'
# )


# aj_data_combinations_prob_threshold[['strata']]
# final_adjusted_data[['strata']]
```
