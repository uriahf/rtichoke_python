---
title: "Before we Validate Performance"
author: "Uriah Finkel"
format: 
    html:
        echo: false
mermaid-format: svg
---

Ideally we would like to keep Performance Validation as agnostic as possible. However, the structure of the validation set (`probs`, `reals` and `times`) implies the nature of the related assumptions and the required use case.

So before we validate performance, let us consider the underlying process.

âœï¸ The User Inputs\
ğŸª› Internal Function

# âœï¸ Declare reference groups

The dimentions of the `probs` and the `real` dictionaries imply the nature of the use case:

TODO: copy from rtichoke r README.

##### One Model, One Population:

-   Just one reference group: "model".

##### Several Models, One Population:

Compare between different candidate models. - Each model stand as a reference groups such as "thin" model, or a "full" model.

##### Several Models, Several Populations

Compare performance over different sub-populations. - Internal Validation: "test", "val" and "train". - External Validation: "Framingham", "Australia". - Fairness: "Male", "Female".

# âœï¸ Declare how to stratify predictions âœ‚ï¸

The `stratified_by` argument is designed for the user to choose how to stratify predictions for decision-making, each method implies different problem:

::: {.panel-tabset}

## Probability Threshold 

::: {.panel-tabset}

By choosing Probability Threshold as a cutoff the implied assumption is that you are concerned with individual harm or benefit.

### Baseline Strategy: Treat None

```{mermaid}

graph LR
    subgraph trt[Treatment Decision]
        linkStyle default stroke:#000
        A("ğŸ˜·") -->|"Treatment ğŸ’Š"|B("<B>Predicted<br>Positive</B><br>ğŸ’Š<br>ğŸ˜·")
        A -->|"No Treatment"|C("<B>Predicted<br>Negative</B><br>ğŸ˜·")    
    end

    subgraph ut[Utility of the Decision]
        subgraph pred[Prediction Model]
            B -->|"Disease ğŸ¤¢"| D["<B>TP</B><br>ğŸ’Š<br>ğŸ¤¢"]
            B -->|"No Disease ğŸ¤¨"| E["<B>FP</B><br>ğŸ’Š<br>ğŸ¤¨"]
            C -->|"Disease ğŸ¤¢"| F["<B>FN</B><br>ğŸ¤¢"]
            C -->|"No Disease ğŸ¤¨"| G["<B>TN</B><br>ğŸ¤¨"]
        end
        subgraph baselinestrategy[Baseline Strategy: Treat None]
            Dnone["<B>FN</B><br>ğŸ¤¢"]
            Enone["<B>TN</B><br>ğŸ¤¨"]
            Fnone["<B>FN</B><br>ğŸ¤¢"]
            Gnone["<B>TN</B><br>ğŸ¤¨"]
        
            D---Dnone
            E---Enone
            F---Fnone
            G---Gnone
        end
        subgraph nb[Net Benefit]
            Dnb[1]
            Enb["pt / (1-pt)"]
            Fnb[0]
            Gnb[0]
        Dnone---Dnb
        Enone---Enb
        Fnone---Fnb
        Gnone---Gnb
        end
    end



    style A fill:#E8F4FF, stroke:black,color:black
    style B fill:#E8F4FF, stroke:black,color:black
    style C fill:#E8F4FF, stroke:black,color:black
    style D fill:#C0FFC0,stroke:black,color:black
    style Dnone fill:#FFCCE0,stroke:black,color:black
    style Dnb fill: #C0FFC0,stroke:black,color:black
    style E fill: #FFCCE0,stroke:black,color:black
    style Enone fill: #C0FFC0,stroke:black,color:black
    style Enb fill: #FFCCE0,stroke:black,color:black
    style F fill:#FFCCE0,stroke:black,color:black
    style Fnone fill: #FFCCE0,stroke:black,color:black
    style Fnb fill: #E8F4FF,stroke:black,color:black
    style G fill: #C0FFC0,stroke:black,color:black
    style Gnone fill: #C0FFC0,stroke:black,color:black
    style Gnb fill: #E8F4FF,stroke:black,color:black
    style nb fill: #E8F4FF,stroke:black,color:black 
    style pred fill: #E8F4FF,stroke:black,color:black
    style baselinestrategy fill: #E8F4FF,stroke:black,color:black

    classDef subgraphStyle fill:#FAF6EC,stroke:#333,stroke-width:1px
    class trt,ut subgraphStyle

```

### Baseline Strategy: Treat All

```{mermaid}

graph LR
    subgraph trt[Treatment Decision]
        linkStyle default stroke:#000
        A("ğŸ˜·") -->|"Treatment ğŸ’Š"|B("<B>Predicted<br>Positive</B><br>ğŸ’Š<br>ğŸ˜·")
        A -->|"No Treatment"|C("<B>Predicted<br>Negative</B><br>ğŸ˜·")    
    end

    subgraph ut[Utility of the Decision]
        subgraph pred[Prediction Model]
            B -->|"Disease ğŸ¤¢"| D["<B>TP</B><br>ğŸ’Š<br>ğŸ¤¢"]
            B -->|"No Disease ğŸ¤¨"| E["<B>FP</B><br>ğŸ’Š<br>ğŸ¤¨"]
            C -->|"Disease ğŸ¤¢"| F["<B>FN</B><br>ğŸ¤¢"]
            C -->|"No Disease ğŸ¤¨"| G["<B>TN</B><br>ğŸ¤¨"]
        end
        subgraph baselinestrategy[Baseline Strategy: Treat All]
            Dall["<B>TP</B><br>ğŸ’Š<br>ğŸ¤¢"]
            Eall["<B>FP</B><br>ğŸ’Š<br>ğŸ¤¨"]
            Fall["<B>TP</B><br>ğŸ’Š<br>ğŸ¤¢"]
            Gall["<B>FP</B><br>ğŸ’Š<br>ğŸ¤¨"]
        
            D---Dall
            E---Eall
            F---Fall
            G---Gall
        end
        subgraph nb[Net Benefit]
            Dnb[0]
            Enb[0]
            Fnb["(1-pt) / pt"]
            Gnb["1"]
        Dall---Dnb
        Eall---Enb
        Fall---Fnb
        Gall---Gnb
        end
    end



    style A fill:#E8F4FF, stroke:black,color:black
    style B fill:#E8F4FF, stroke:black,color:black
    style C fill:#E8F4FF, stroke:black,color:black
    style D fill:#C0FFC0,stroke:black,color:black
    style Dall fill:#C0FFC0,stroke:black,color:black
    style Dnb fill:#E8F4FF,stroke:black,color:black
    style E fill:#FFCCE0,stroke:black,color:black
    style Eall fill:#FFCCE0,stroke:black,color:black
    style Enb fill:#E8F4FF,stroke:black,color:black
    style F fill:#FFCCE0,stroke:black,color:black
    style Fall fill:#C0FFC0,stroke:black,color:black
    style Fnb fill:#FFCCE0,stroke:black,color:black
    style G fill:#C0FFC0,stroke:black,color:black
    style Gall fill:#FFCCE0,stroke:black,color:black
    style Gnb fill:#C0FFC0,stroke:black,color:black
    style nb fill: #E8F4FF,stroke:black,color:black 
    style pred fill: #E8F4FF,stroke:black,color:black
    style baselinestrategy fill: #E8F4FF,stroke:black,color:black

    classDef subgraphStyle fill:#FAF6EC,stroke:#333,stroke-width:1px
    class trt,ut subgraphStyle

```

*Regardless* of ranking each prediction is categorised to a bin: 0.32 -\> `[0.3, 0.4)`.

1.  Categorise Absolute Risk: 0.32 -\> `[0.3, 0.4)`

References: Pauker SG, Kassirer JP. Therapeutic decision making: a cost-benefit analysis. N Engl J Med. 1975;293(5):229-234. doi:10.1056/NEJM197507312930505

:::

## PPCR

![](line_ppcr_04.svg)

```{mermaid}

graph LR
    subgraph trt[Treatment Allocation Decision]
        linkStyle default stroke:#000
        A("ğŸ˜·<br>ğŸ˜·<br>ğŸ˜·<br>ğŸ˜·<br>ğŸ˜·<br>ğŸ˜·<br>ğŸ˜·<br>ğŸ˜·<br>ğŸ˜·<br>ğŸ˜·") -->|"Treatment ğŸ’ŠğŸ’ŠğŸ’ŠğŸ’Š"|B("<B>Î£ Predicted<br>Positives</B><br>ğŸ’ŠğŸ’ŠğŸ’ŠğŸ’Š<br>ğŸ˜·ğŸ˜·ğŸ˜·ğŸ˜·")
        A -->|"No Treatment"|C("<B>Î£ Predicted<br>Negatives</B><br>ğŸ˜·ğŸ˜·ğŸ˜·ğŸ˜·ğŸ˜·ğŸ˜·")    
    end

    subgraph ut[Utility of the Decision]
        B -->|"Disease ğŸ¤¢ğŸ¤¢ğŸ¤¢"| D["<B>Î£ TP</B><br>ğŸ’ŠğŸ’ŠğŸ’Š<br>ğŸ¤¢ğŸ¤¢ğŸ¤¢"]
        B -->|"No Disease ğŸ¤¨"| E["<B>Î£ FP</B><br>ğŸ’Š<br>ğŸ¤¨"]
        C -->|"Disease ğŸ¤¢"| F["<B>Î£ FN</B><br>ğŸ¤¢"]
        C -->|"No Disease ğŸ¤¨ğŸ¤¨ğŸ¤¨ğŸ¤¨ğŸ¤¨"| G["<B>Î£ TN</B><br>ğŸ¤¨ğŸ¤¨ğŸ¤¨ğŸ¤¨ğŸ¤¨"]  
    end



    style A fill:#E8F4FF, stroke:black,color:black
    style B fill:#E8F4FF, stroke:black,color:black
    style C fill:#E8F4FF, stroke:black,color:black
    style D fill:#C0FFC0,stroke:black,color:black
    style E fill:#FFCCE0,stroke:black,color:black
    style F fill:#FFCCE0,stroke:black,color:black
    style G fill:#C0FFC0,stroke:black,color:black

    classDef subgraphStyle fill:#FAF6EC,stroke:#333,stroke-width:1px
    class trt,ut subgraphStyle

```

By choosing PPCR as a cutoff the implied assumption is that you are concerned with resource constraint and assume no individual treatment harm.

*Regarding* the ranking each prediction is categorised to a bin: if the absolute probability 0.32 is the 18th highest predictions out of 100, it will be categorised to the second decile -\> `0.18`.

1.  Calculate Risk-Quantile from Absolute Risk: 0.32 -\> `0.18`

References: https://en.wikipedia.org/wiki/Precision_and_recall

:::

# âœï¸ Declare Fixed Time Horizons ğŸŒ… (ğŸ“…ğŸ¤¬)

The `fixed_time_horizons` argument is designed for the user to choose the set of time horizons to follow.

Different followups contain different distributions of observed outcomes: Declare fixed time horizons for the prediction model, such as \[5, 10\] years of prediction for CVD evet.

## ğŸª› Update Administrative Censorng

For cases with observed time-to-event is shorter than the prediction time horizon, the outcomes might change:

-   `Real Positives` ğŸ¤¢ should be considered as `Real Negatives` ğŸ¤¨, the outcome of interest did not happen yet.

-   Always included and Encoded as 0.

-   `Real Neagtives` ğŸ¤¨ should be considered as `Real Censored` ğŸ¤¬, the event of interest could have happened in the gap between the observed time and the fixed time horizon.

-   If adjusted: encoded as 0.

-   If excluded: counted with crude estimate.

```{python}

import numpy as np

times = np.array([24.1, 9.7, 49.9, 18.6, 34.8, 14.2, 39.2, 46.0, 31.5, 4.3])
reals = np.array([1, 1, 1, 1, 0, 2, 1, 2, 0, 1])
time_horizons = [10, 20, 30, 40, 50]

# Icons
def get_icon(outcome, t, h):
    if outcome == 0:
        return "ğŸ¤¬" if t < h else "ğŸ¤¨"
    elif outcome == 1:
        return "ğŸ¤¢"
    elif outcome == 2:
        return "ğŸ’€"

# Displayed time
def get_time(outcome, t, h):
    if outcome == 0:
        return t if t < h else h
    else:
        return t

# Final output
final_data = []

for i in range(len(times)):
    id_ = i + 1
    t = times[i]
    r = reals[i]

    for h in time_horizons:
        outcome = r if t <= h else 0  # override outcome after horizon
        final_data.append({
            "id": id_,
            "time_horizon": h,
            "time": get_time(outcome, t, h),
            "real": get_icon(outcome, t, h)
        })

ojs_define(data = final_data)

```

```{ojs}

filteredData = data.filter((d) => d.time_horizon == timeHorizon)

viewof timeHorizon = Inputs.range([10, 50], {
  step: 10,
  value: 50,
  label: "Time Horizon"
})

Plot.plot({
  x: {
    domain: [0, 50]
  },
  y: {
    domain: [0, 11],
    axis: false
  },
  marks: [
    Plot.ruleX([timeHorizon], {
      stroke: "#D9E8A3",
      strokeWidth: 6,
      strokeDasharray: "5,5",
      y1: 0,
      y2: 10 // Should match the y-domain max
    }),
    Plot.ruleY(filteredData, {
      x: "time",
      y: "id",
      strokeWidth: 1.5
    }),
    Plot.text(filteredData, {
      x: "time",
      y: "id",
      text: "real",
      tip: true,
      fontSize: 30
    })
  ]
})

```

