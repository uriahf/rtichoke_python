{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Hello, Quarto\"\n",
        "format: html\n",
        "echo: false\n",
        "message: false\n",
        "warning: false\n",
        "---"
      ],
      "id": "9d49eb4d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from lifelines import AalenJohansenFitter\n",
        "import numpy as np\n",
        "from itertools import product\n",
        "import itertools\n",
        "from rtichoke.helpers.sandbox_observable_helpers import *\n",
        "from lifelines import CoxPHFitter\n",
        "from lifelines import WeibullAFTFitter\n",
        "\n",
        "import pandas as pd\n",
        "import pickle  \n",
        "\n",
        "with open(r'C:\\Users\\I\\Documents\\GitHub\\rtichoke_python\\probs_dict.pkl', 'rb') as file:\n",
        "    probs_dict = pickle.load(file)\n",
        "\n",
        "with open(r'C:\\Users\\I\\Documents\\GitHub\\rtichoke_python\\reals_dict.pkl', 'rb') as file:\n",
        "    reals_dict = pickle.load(file)\n",
        "\n",
        "with open(r'C:\\Users\\I\\Documents\\GitHub\\rtichoke_python\\times_dict.pkl', 'rb') as file:\n",
        "    times_dict = pickle.load(file)\n"
      ],
      "id": "caa1093e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fixed_time_horizons = [1, 3, 5]\n",
        "stratified_by = [\"probability_threshold\", \"ppcr\"]\n",
        "\n",
        "aj_data_combinations = create_aj_data_combinations(list(probs_dict.keys()), fixed_time_horizons, stratified_by, 0.1)"
      ],
      "id": "b0abf9e3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Create reference groups\n",
        "reference_groups = list(probs_dict.keys())\n",
        "data_to_adjust = pd.DataFrame({\n",
        "  \"reference_group\": np.repeat(reference_groups, len(reals_dict)),\n",
        "  \"probs\": np.concatenate([probs_dict[group] for group in reference_groups]),\n",
        "  \"reals\": np.tile(reals_dict, len(reference_groups)),\n",
        "  \"times\": np.tile(times_dict, len(reference_groups))\n",
        "})\n",
        "\n",
        "# # Placeholder for add_cutoff_strata function\n",
        "data_to_adjust = add_cutoff_strata(data_to_adjust, by=0.1)"
      ],
      "id": "ebe70380",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "data_to_adjust = pivot_longer_strata(data_to_adjust)\n",
        "\n",
        "data_to_adjust[\"reals\"] = data_to_adjust[\"reals\"].replace({\n",
        "    0: \"real_negatives\",\n",
        "    2: \"real_competing\",\n",
        "    1: \"real_positives\"\n",
        "})\n",
        "\n",
        "\n",
        "data_to_adjust[\"reals\"] = pd.Categorical(data_to_adjust[\"reals\"], categories=[\"real_negatives\", \"real_competing\", \"real_positives\"], ordered=True)\n",
        "\n",
        "# Splitting data by reference group\n",
        "list_data_to_adjust = {k: v for k, v in data_to_adjust.groupby(\"reference_group\")}\n",
        "\n",
        "\n",
        "# # Define assumption sets\n",
        "assumption_sets = [\n",
        "    {\"competing\": \"excluded\", \"censored\": \"excluded\"},\n",
        "    {\"competing\": \"adjusted_as_negative\", \"censored\": \"adjusted\"},\n",
        "    {\"competing\": \"adjusted_as_censored\", \"censored\": \"adjusted\"},\n",
        "    {\"competing\": \"excluded\", \"censored\": \"adjusted\"},\n",
        "    {\"competing\": \"adjusted_as_negative\", \"censored\": \"excluded\"}\n",
        "]"
      ],
      "id": "a2074ed1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "adjusted_data_list = create_adjusted_data_list(\n",
        "  list_data_to_adjust=list_data_to_adjust,\n",
        "  fixed_time_horizons=fixed_time_horizons,\n",
        "  assumption_sets=assumption_sets\n",
        ")\n"
      ],
      "id": "68c29607",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Combine all adjusted data\n",
        "final_adjusted_data = pd.concat(adjusted_data_list, ignore_index=True)\n",
        "\n",
        "aj_data_combinations['strata'] = aj_data_combinations['strata'].astype(str)\n",
        "\n",
        "final_adjusted_data['strata'] = final_adjusted_data['strata'].astype(str)\n",
        "\n",
        "aj_data_combinations['reals'] = aj_data_combinations['reals'].astype(str)\n",
        "\n",
        "final_adjusted_data['reals'] = final_adjusted_data['reals'].astype(str)\n",
        "\n",
        "categories = [\"real_negatives\", \"real_positives\", \"real_competing\", \"real_censored\"]\n",
        "aj_data_combinations['reals'] = pd.Categorical(aj_data_combinations['reals'], categories=categories, ordered=True)\n",
        "final_adjusted_data['reals'] = pd.Categorical(final_adjusted_data['reals'], categories=categories, ordered=True)\n",
        "\n",
        "combined_adjusted_data = aj_data_combinations.merge(final_adjusted_data, on=[\"reference_group\", \"fixed_time_horizon\", \"censoring_assumption\", \"competing_assumption\", \"reals\", \"strata\"], how='left')"
      ],
      "id": "31d5dbc3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "\n",
        "# combined_adjusted_data = pd.read_pickle(\"C:\\Users\\I\\Documents\\GitHub\\rtichoke_python\\docs\\combined_adjusted_data.pkl\")\n",
        "\n",
        "# TODO: When I read pickle something is goes wrong\n",
        "\n",
        "ojs_define(reference_groups_data = reference_groups)\n",
        "\n",
        "ojs_define(data = combined_adjusted_data)"
      ],
      "id": "d9c7a473",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{ojs}\n",
        "\n",
        "//| panel: input\n",
        "\n",
        "viewof time_horizon = Inputs.range(\n",
        "  [1, 5], \n",
        "  {value: 3, step: 2, label: \"Time Horizon:\"}\n",
        ")\n",
        "\n",
        "viewof reference_group = Inputs.radio(\n",
        "  reference_groups_data, {label: \"Reference Group\"}, {value: 'thin'}\n",
        ")\n",
        "\n",
        "viewof stratified_by = Inputs.radio(\n",
        "  [\"probability_threshold\", \"ppcr\"], {value: \"probability_threshold\", label: \"Stratified By\"}\n",
        ")\n",
        "\n",
        "viewof censored_assumption = Inputs.radio(\n",
        "  [\"excluded\", \"adjusted\"], {value: \"excluded\", label: \"Censored Assumption\"}\n",
        ")\n",
        "\n",
        "viewof competing_assumption = Inputs.radio(\n",
        "  [\"excluded\", \"adjusted_as_negative\", \"adjusted_as_censored\", \"reals\"], {value: \"excluded\", label: \"Competing Assumption\"}\n",
        ")\n",
        "\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "\n",
        "//cumulative_aj_data_filtered = transpose(cumulative_aj_data).filter(function(subset) {\n",
        "//\n",
        "//  return time_horizon == subset.fixed_time_horizon &&\n",
        "//         censored_assumption == subset.censored_assumption &&\n",
        "//         competing_assumption == subset.competing_assumption &&\n",
        "//         stratified_by == subset.stratified_by && \n",
        "//         reference_group === subset.reference_group;\n",
        "//})\n",
        "\n",
        "filtered = transpose(data).filter(function(subset) {\n",
        "\n",
        "  return time_horizon == subset.fixed_time_horizon &&\n",
        "         censored_assumption == subset.censoring_assumption &&\n",
        "         competing_assumption == subset.competing_assumption &&\n",
        "         stratified_by === subset.stratified_by && \n",
        "         reference_group === subset.reference_group;\n",
        "})\n",
        "\n",
        "filtered\n",
        "\n",
        "\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "\n",
        "  \n",
        "Plot.plot({\n",
        "  marks: [\n",
        "    Plot.barY(filtered, { \n",
        "      x: \"strata\", \n",
        "      y: \"reals_estimate\", \n",
        "      fill: \"reals\", \n",
        "      tip: true \n",
        "    })\n",
        "  ],\n",
        "  color: {\n",
        "    domain: [\"real_positives\", \"real_competing\", \"real_negatives\", \"real_censored\"], \n",
        "    range: [\"#009e73\", \"#9DB4C0\", \"#FAC8CD\", \"#E3F09B\"],\n",
        "    legend: true\n",
        "  }\n",
        "})\n",
        "\n",
        "``` "
      ],
      "id": "c0d1c53b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# combined_adjusted_data.dropna(subset=['reals_estimate'])\n",
        "# # \n",
        "\n",
        "# Perform left join between aj_data_combinations and final_adjusted_data on 'strata' and 'reals_estimate'\n",
        "# only when stratified_by == 'probability_threshold' for aj_data_combinations\n",
        "\n",
        "# aj_data_combinations_prob_threshold = aj_data_combinations[aj_data_combinations['stratified_by'] == 'probability_threshold']\n",
        "\n",
        "# # Convert 'strata' columns to strings\n",
        "# aj_data_combinations_prob_threshold['strata'] = aj_data_combinations_prob_threshold['strata'].astype(str)\n",
        "# final_adjusted_data['strata'] = final_adjusted_data['strata'].astype(str)\n",
        "\n",
        "# combined_adjusted_data = aj_data_combinations_prob_threshold.merge(\n",
        "#     final_adjusted_data[['strata', 'reals', 'reals_estimate']],\n",
        "#     on=['strata', 'reals'],\n",
        "#     how='left'\n",
        "# )\n",
        "\n",
        "\n",
        "# aj_data_combinations_prob_threshold[['strata']]\n",
        "# final_adjusted_data[['strata']]"
      ],
      "id": "0f7c69c0",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "c:\\Users\\I\\Documents\\GitHub\\rtichoke_python\\.venv\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}